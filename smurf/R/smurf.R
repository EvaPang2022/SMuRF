#' SMuRF v1.6
#'
#' Somatic mutation consensus calling based on four callers:
#' MuTect2, Freebayes, VarDict, VarScan
#' using a RandomForest model to consolidate a list of high accuracy calls.
#'
#' @note
#' Input files containing variant calls should be ".vcf.gz" format of each caller.
#' Supported for R (>=3.3.1), Java 7 or 8. For R (>=3.5.1), Java (7 up to 11 is supported). 
#' 
#' @param directory Choose directory where the files Variant Caller Format(VCF) files are located. 
#' Alternatively, provide a list object containing the path to the 4 VCF files labelled: mutect, freebayes, vardict and varscan.
#'
#' @param model Choose "combined", "cdsannotation", "featureselectionall", "newcutoff.cdsannotation" or "ROI".
#' The appropriate parsing and prediction model will be performed
#' to obtain a list of somatic mutation calls. 
#' 
#' Choose "combined" to generate both SNV and Indel outputs
#' 
#' Choose "cdsannotation" to run "combined" + add annotations to coding regions (from the respective coding transcripts)
#' 
#' To change the cutoffs for completed/existing SMuRF output, select "newcutoff.cdsannotation".
#' 
#' To obtain variants of a specific region, use "ROI" and provide the .BED file of genomic coordinates.
#' 
#' Debug mode: Choose "featureselectionall" to parse the VCF files only.
#' 
#' @param nthreads Default as "-1", where all available cores will be used for RandomForest prediction. 
#' Specify any integer from 1 to x, depending on your resources available.
#' For 32-bit Windows, only 1 core is allowed (nthreads=1).
#' 
#' @param snv.cutoff Default SNV model cutoff, unless a number between 0 to 1 is stated. 
#' 
#' @param indel.cutoff Default indel model cutoff, unless a number between 0 to 1 is stated.
#' 
#' @param t.label Default as "-T" to identify your tumour sample (from your normal sample). 
#' If your tumour BAM file is named "SampleA_tumour", set t.label = "_tumour".
#' 
#' @param save.files Select save.files=T to save the SMuRF output as .txt files in your specified output.dir. 
#' Default save.files=F, SMuRF output is available as a list object in R. 
#' 
#' @param output.dir Path to output directory
#' 
#' @param parse.dir Path to the location of existing snv-parse.txt and indel-parse.txt files generated by SMuRF (following this format). 
#' This setting is available for model="newcutoff.cdsannotation".
#' 
#' @param roi.dir Path to the location of a .BED or .txt file with regions-of-interest.
#' This setting is available for model="ROI".
#' 
#' @param build Default genome build='hg19'. Set to "hg38" for GRCh38 build. 
#' This setting affects the gene annotation but not the SMuRF predictions for SNVs and indels.
#' 
#' @param change.build For conversion of your genomic coordinates.
#' change.build = 'hg19.to.hg38' or 'hg38.to.hg19'. 
#' Default option is disabled to retain your original 'build' specified above. 
#' 
#' @param check.packages Default as 'TRUE'. For debug mode.
#' 
#' @examples
#' myresults = smurf(directory="/path/to/directory..",
#'                   model="combined", t.label='-TCGA-Tumor')
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   model="cdsannotation",
#'                   save.files=T, output.dir="/path/to/output")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   model="newcutoff.cdsannotation",
#'                   nthreads = 4,
#'                   snv.cutoff = 0.2, indel.cutoff = 'default',
#'                   parse.dir="/path/to/parse/files/")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   model="ROI",
#'                   roi.dir="/path/to/dir/roi.bed", build='hg38')
#' 
#' #Specify directories manually
#' dir.list = list(mutect='/path/to/mutect.vcf.gz',
#'                 freebayes='/path/to/freebayes.vcf.gz',
#'                 vardict='/path/to/vardict.vcf.gz',
#'                 varscan='/path/to/varscan.vcf.gz')
#'                  
#' myresults = smurf(directory=dir.list, 
#'                   model="combined")
#'                                    
#' @export
#' 
smurf = function(directory=NULL, model=NULL, nthreads = -1,
                 save.files=F,  output.dir=NULL, parse.dir=NULL, roi.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 t.label='-T', build='hg19', change.build=F,
                 check.packages=T){
  
  #SMuRF version announcement
  print("SMuRFv1.6 (9th Sept 2019)")
  

  if(is.null(directory)){
    # stop('directory path not specified')
    return(write("smurf(directory=NULL, model=NULL, nthreads = -1,
                 save.files=F,  output.dir=NULL, parse.dir=NULL, roi.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 t.label='-T', build='hg19', change.build=F,
                 check.packages=T)", stdout()))
  }
  
  if(!is.null(directory) & class(directory)!='list'){
    if(dir.exists(directory)==F){
      stop('directory path does not exist')
    }
  }
  
  if (model != "combined" & 
      model != "cdsannotation" & 
      model != "featureselectionall" & 
      model != "newcutoff.cdsannotation" & 
      model != "ROI") {
    stop('model unrecognized')
  }
  
  if(snv.cutoff != 'default' & (snv.cutoff < 0 | snv.cutoff > 1) ){
    stop('snv.cutoff out of range')
  }
  
  if(indel.cutoff != 'default' & (indel.cutoff < 0 | indel.cutoff > 1) ){
    stop('indel.cutoff out of range')
  }
  
  if (save.files == T & is.null(output.dir)) {
    stop('output.dir path not specified')
  }  
  
  if (save.files == T & !is.null(output.dir)) {
    if(dir.exists(output.dir)==F){
      print(paste0('Creating output dir: ',output.dir))
      dir.create(output.dir)
    } else {
      print(paste0('Saving output files to: ',output.dir))
    }
  }
  
  if (class(directory)!='list') {
    # directory <-paste(directory,"/", sep="")
    mutect2 <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz"))
    freebayes <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz"))
    varscan <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz"))
    vardict <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz"))
    x<-list(mutect2,freebayes,varscan,vardict)
    
    if(length(grep("mutect", mutect2))!=1 & 
       length(grep("freebayes", freebayes))!=1 & 
       length(grep("varscan", varscan))!=1 & 
       length(grep("vardict", vardict))!=1){
      stop('Input file check failed. Directory contains missing or duplicated vcf files due to similar file names. 
           You may specify your path to four caller files as a list object manually.')
    }
  } else if (class(directory)=='list'){
    x = directory
    if (length(x)!=4){
      stop('Input file check failed. Directory contains incorrect number of vcf files.')
    }
  }
  
  if(model == "cdsannotation"){
    mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
    freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
    varscan.tbi <- Sys.glob(paste0(directory,"*/varscan*.vcf.gz.tbi"))
    vardict.tbi <- Sys.glob(paste0(directory,"*/vardict*.vcf.gz.tbi"))
    tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi)
    
    if(length(grep("mutect", mutect2.tbi))!=1 & 
       length(grep("freebayes", freebayes.tbi))!=1 & 
       length(grep("varscan", varscan.tbi))!=1 & 
       length(grep("vardict", vardict.tbi))!=1){
      print('tab-indexed (.tbi) files required for cdsannotation not found.')
    } else {
      print('Generating .tbi files in directory...')
      library(Rsamtools)
      indexTabix(x[[1]], format = 'vcf')
      indexTabix(x[[2]], format = 'vcf')
      indexTabix(x[[3]], format = 'vcf')
      indexTabix(x[[4]], format = 'vcf')
      write("DONE",stdout())
    }
    
  }
  
  if (model == "newcutoff.cdsannotation" & is.null(parse.dir)) {
    stop('parse.dir path not specified')
  }  
  
  if (model == "newcutoff.cdsannotation" & !is.null(parse.dir)) {
    if(dir.exists(parse.dir)==F){
      stop('parse.dir path does not exist. newcutoff.cdsannotation requires path to parse.txt files')
    } else {
      print('Checking parse directory')
      snv.parse.dir <- Sys.glob(paste0(parse.dir,'/',"snv-parse*"))
      indel.parse.dir <- Sys.glob(paste0(parse.dir,'/',"indel-parse*"))
      
      if(length(snv.parse.dir)==1) {
           print(paste0(snv.parse.dir, ' found'))
        } else {
           print('snv-parse.txt not found or duplicated in parse.dir')
        }
      if(length(indel.parse.dir)==1) {
        print(paste0(indel.parse.dir, ' found'))      
      } else {
        print('indel-parse.txt not found or duplicated in parse.dir')
      }
    }
  }
  
  if(model == "ROI" & is.null(roi.dir)){
    stop('roi.dir path not specified')
  }
  
  if(model == "ROI" & !is.null(roi.dir)){
    if(file.exists(roi.dir)==F){
      write("model=='ROI'. Using roi.dir to subset VCFs.",stdout())
    }
  }
  
  if(model == "cdsannotation"){
    print(paste0('Genome build: ', build))  
  }
  
    
    #check for existing and required packages
    
  if(check.packages == T) {
    if (getRversion()<3.5) {
    
    if("VariantAnnotation" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("VariantAnnotation")
    }
    
    if("Rsamtools" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("Rsamtools")
      }
      
      #check for h2o version 3.10.3.3
      if("h2o" %in% rownames(installed.packages()) == FALSE){
        print("h2o version 3.10.3.3 not found. Installing required h2o package.")
        install.packages(paste0(find.package("smurf"), "/data/h2o_3.10.3.3.tar.gz"), type="source", repos=NULL)
        # install.packages("versions")
        # library(versions)
        # install.versions("h2o", versions = "3.10.3.3")
        print("h2o version 3.10.3.3 installed.")
        
      } else {
        if((packageVersion("h2o") == '3.10.3.3') == FALSE){
          print("Incorrect h2o version found. Installing h2o version 3.10.3.3.")
          if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
          if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
          install.packages(paste0(find.package("smurf"), "/data/h2o_3.10.3.3.tar.gz"), type="source", repos=NULL)
          # install.packages("versions")
          # library(versions)
          # install.versions("h2o", versions = "3.10.3.3")
          print("h2o version 3.10.3.3 installed.")
        }  
      }
      
    } else {
      
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    BiocManager::install()
    # BiocManager::install(c("VariantAnnotation"))
    }
    
    #check for h2o version 3.26.0.2
    if("h2o" %in% rownames(installed.packages()) == FALSE){
      print("h2o version 3.26.0.2 not found. Installing required h2o package.")
      # install.packages(paste0(find.package("smurf"), "/data/h2o_3.26.0.2.tar.gz"), type="source", repos=NULL)
      install.packages("versions")
      library(versions)
      install.versions("h2o", versions = "3.26.0.2")
      print("h2o version 3.26.0.2 installed.")
      
    } else {
      if((packageVersion("h2o") == '3.26.0.2') == FALSE){
        print("Incorrect h2o version found. Installing h2o version 3.26.0.2.")
        if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
        if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
        # install.packages(paste0(find.package("smurf"), "/data/h2o_3.26.0.2.tar.gz"), type="source", repos=NULL)
        install.packages("versions")
        library(versions)
        install.versions("h2o", versions = "3.26.0.2")
        print("h2o version 3.26.0.2 installed.")
      }  
      }
    }
  }
  
  if (! ("data.table" %in% rownames(installed.packages()))) { install.packages("data.table") }
  if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
  # if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
  if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
  if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
  if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
  if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
  if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
  if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
  if (! ("dplyr" %in% rownames(installed.packages()))) { install.packages("dplyr") }
    

    #load packages
  
    suppressWarnings(suppressMessages(library(VariantAnnotation)))

    if (model != "newcutoff.cdsannotation") {
      
      suppressWarnings(suppressMessages(library(h2o)))
      suppressWarnings(h2o.init(nthreads = nthreads))
      
    }
    
    # if (exists("nthreads")==FALSE){
    #   nthreads=-1
    # }

    
    
    #Retrieving files from the directory
    
    write("Accessing files:", stderr())
    write("Accessing files:", stdout())
    write(mutect2, stderr())
    write(mutect2, stdout())
    write(freebayes, stderr())
    write(freebayes, stdout())
    write(varscan, stderr())
    write(varscan, stdout())
    write(vardict, stderr())
    write(vardict, stdout())
    
    start.time <- Sys.time()
    
    if (model == "combined") {
      parsevcf<-parsevcf_allfeaturesall(x,t.label)
      snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
      indelpredict<-indelRFpredict(parsevcf, indel.cutoff)
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("smurf_snv"=snvpredict,
                                  "smurf_indel"=indelpredict,
                                  "time.taken"=time.taken),
                   output.dir)
      }
        
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "time.taken"=time.taken))
    
    
    } else if (model == "cdsannotation") {
      
      parsevcf<-parsevcf_allfeaturesall(x,t.label)
      
      snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
      indelpredict<-indelRFpredict(parsevcf, indel.cutoff)
      
      if (length(snvpredict)>1) {
        print("SNV annotation")
        snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
      } else {
        print("No snv predictions. Skipping snv annotation step.")
        snvannotation=NULL
      }
      
      if (length(indelpredict)>1) {
        print("Indel annotation")
        indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
      } else {
        print("No indel predictions. Skipping indel annotation step.")
        indelannotation=NULL
      }
      
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("smurf_snv"=snvpredict,
                                  "smurf_indel"=indelpredict,
                                  "smurf_snv_annotation"=snvannotation,
                                  "smurf_indel_annotation"=indelannotation,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
      

      } else if (model == "ROI") { #retrieve subset
      
      print('Retrieving ROI subset...')
      
      parse.roi = read.vcf(x, roi=T, roi.dir=roi.dir,t.label)
      
      if (!is.null(nrow(parse.roi[[1]]))) {
        print(paste0('There are ', nrow(parse.roi[[1]]),' snv predictions found in ROI.'))
        snv.roi<-snvRFpredict(parse.roi, snv.cutoff)

        if (length(snv.roi)>1) {
          print("SNV annotation")
          snv.roi.annotation<-CDSannotation_snv(x,snv.roi,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snv.roi.annotation=NULL
        }
        
      } else {
        print("No snv predictions found in ROI.")
        snv.roi.annotation=NULL
      }
      
      if (!is.null(nrow(parse.roi[[2]]))) {
        print(paste0('There are ', nrow(parse.roi[[2]]),' indel predictions found in ROI.'))
        indel.roi<-indelRFpredict(parse.roi, indel.cutoff,build=build,change.build=change.build)
        
        if (length(indel.roi)>1) {
          print("Indel annotation")
          indel.roi.annotation<-CDSannotation_indel(x,indel.roi)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indel.roi.annotation=NULL
        }
        
      } else {
        print("No indel predictions found in ROI.")
        indel.roi.annotation=NULL
      }
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("smurf_snv"=snv.roi,
                                  "smurf_indel"=indel.roi,
                                  "smurf_snv_annotation"=snv.roi.annotation,
                                  "smurf_indel_annotation"=indel.roi.annotation,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("smurf_snv"=snv.roi, "smurf_indel"=indel.roi,
                  "smurf_snv_annotation"=snv.roi.annotation, "smurf_indel_annotation"=indel.roi.annotation,
                  "time.taken"=time.taken))
      

      
    } else if (model == "featureselectionall") { #debug mode, only parse feature matrix
      parsevcf<-parsevcf_allfeaturesall(x)
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("parsevcf_featureselection"=parsevcf,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("parsevcf_featureselection"=parsevcf, "time.taken"=time.taken))
      
    
    } else if (model == "newcutoff.cdsannotation") { #requires parse feature matrix for re-assigning cutoff and cdsannotation
      
      if(length(snv.parse.dir)==1) {
        parse_snv = read.table(snv.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
      } else {parse_snv=NA}
      if(length(indel.parse.dir)==1) {
        parse_indel = read.table(indel.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
      } else {parse_indel=NA}
      
      parsevcf = list(snv=parse_snv, indel=parse_indel)
      
      if(length(snv.parse.dir)==1) {
        snvpredict<-newcutoff_snv(parsevcf, snv.cutoff)
      } else {parse_snv=NA}
      if(length(indel.parse.dir)==1) {
        indelpredict<-newcutoff_indel(parsevcf, indel.cutoff)
      } else {parse_indel=NA}
      
      if (length(snvpredict)>1) {
        print("SNV annotation")
        snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
      } else {
        print("No snv predictions. Skipping snv annotation step.")
        snvannotation=NULL
      }
      
      if (length(indelpredict)>1) {
        print("Indel annotation")
        indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
      } else {
        print("No indel predictions. Skipping indel annotation step.")
        indelannotation=NULL
      }
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("smurf_snv"=snvpredict,
                                  "smurf_indel"=indelpredict,
                                  "smurf_snv_annotation"=snvannotation,
                                  "smurf_indel_annotation"=indelannotation,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
      
    }
          

}  
