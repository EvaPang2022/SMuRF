#' SMuRF v1.6
#'
#' Somatic mutation consensus calling based on four callers:
#' MuTect2, Freebayes, VarDict, VarScan
#' using a RandomForest model to consolidate a list of high accuracy calls.
#'
#' @note
#' Input files containing variant calls should be ".vcf.gz" format of each caller.
#' Supported for R (>=3.3.1), Java 7 or 8. For R (>=3.5.1), Java (7 up to 11 is supported). 
#' 
#' @param directory Choose directory where the files Variant Caller Format(VCF) files are located. 
#' Alternatively, provide a list object containing the path to the 4 VCF files labelled: mutect, freebayes, vardict and varscan.
#'
#' @param mode Choose "snv", "indel" or "combined" (snv+indel). 
#' The appropriate parsing and prediction model will be performed
#' to obtain a list of somatic mutation calls. 
#' 
#' Debug mode: Choose "featureselectionall" to parse the VCF files only.
#' 
#' @param nthreads Default as "-1", where all available cores will be used for RandomForest prediction. 
#' Specify any integer from 1 to x, depending on your resources available.
#' For 32-bit Windows, only 1 core is allowed (nthreads=1).
#' 
#' @param annotation TRUE or FALSE (default). Provide gene annotations for each variant call.
#' 
#' @param snv.cutoff Default SNV model cutoff, unless a number between 0 to 1 is stated. 
#' 
#' @param indel.cutoff Default indel model cutoff, unless a number between 0 to 1 is stated.
#' 
#' @param output.dir Path to output directory (if saving files as .txt)
#' 
#' @param parse.dir Specify if changing SMuRF default cutoffs.
#' Path to the location of existing snv-parse.txt and indel-parse.txt files generated by SMuRF. 
#' 
#' @param whitelist.file Path to .BED or .txt file with region to be parsed into the SMuRF format.
#' All SNVs and INDELS will be retrieved. SMuRF prediction will not be performed.
#' 
#' @param build Genome build='hg19' or "hg38". If unknown, SMuRF will try to detect it.
#' 
#' @param change.build TRUE or FALSE. For conversion of your genomic coordinates.
#' Default option is disabled to retain your original 'build' specified above. 
#' 
#' @param t.label (optional) Provide the sample name for your tumour sample to ease 
#' the identification of the normal and tumour sample names in your vcf.
#' See examples below
#' 
#' @param check.packages Default as TRUE. For debug mode.
#' 
#' @examples
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="indel")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="snv",
#'                   output.dir="/path/to/output")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined",
#'                   nthreads = 4,
#'                   snv.cutoff = 0.2, indel.cutoff = 'default',
#'                   parse.dir="/path/to/parse/files/")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, build='hg19')
#'                   
#' myresults = smurf(directory="/path/to/directory..",
#'                   whitelist.dir="/path/to/dir/roi.bed")
#' 
#' #Change hg38 to hg19 coordinates in gene annotation output
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', change.build=T)
#'                   
#' #Specify tumor sample name
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', t.label = '-T')
#'                                       
#' #Specify directories manually
#' dir.list = list(mutect='/path/to/mutect.vcf.gz',
#'                 freebayes='/path/to/freebayes.vcf.gz',
#'                 vardict='/path/to/vardict.vcf.gz',
#'                 varscan='/path/to/varscan.vcf.gz')
#'                 
#' myresults = smurf(directory=dir.list, 
#'                   model="combined")
#'                                    
#' @export
#' 
smurf = function(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=F, output.dir=NULL, parse.dir=NULL, whitelist.file=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, t.label=NULL,
                 check.packages=T){
  
  #SMuRF version announcement
  print("SMuRFv1.6.2 (24th Oct 2019)")
  

  if(is.null(directory)){
    # stop('directory path not specified')
    return(write("smurf(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=T, output.dir=NULL, parse.dir=NULL, whitelist.file=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, t.label=NULL,
                 check.packages=T)", stdout()))
  }
  
  if(!is.null(directory) & class(directory)!='list'){
    if(dir.exists(directory)==F){
      stop('directory path does not exist')
    }
  }
  
  if(snv.cutoff != 'default' & (snv.cutoff < 0 | snv.cutoff > 1) ){
    stop('snv.cutoff out of range')
  }
  
  if(indel.cutoff != 'default' & (indel.cutoff < 0 | indel.cutoff > 1) ){
    stop('indel.cutoff out of range')
  }
  
  if (!is.null(output.dir)) {
    if(dir.exists(output.dir)==F){
      print(paste0('Creating output dir: ',output.dir))
      dir.create(output.dir)
      save.files = T
    } else {
      print(paste0('Saving output files to: ',output.dir))
      save.files = T
    }
  } else {
    save.files = F
  }
  
  if (class(directory)!='list') {
    # directory <-paste(directory,"/", sep="")
    mutect2 <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz"))
    freebayes <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz"))
    varscan <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz"))
    vardict <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz"))
    x<-list(mutect2,freebayes,varscan,vardict)
    
    if(length(grep("mutect", mutect2))!=1 & 
       length(grep("freebayes", freebayes))!=1 & 
       length(grep("varscan", varscan))!=1 & 
       length(grep("vardict", vardict))!=1){
      stop('Input file check failed. Directory contains missing or duplicated vcf files due to similar file names. 
           You may specify your path to four caller files as a list object manually.')
    }
  } else if (class(directory)=='list'){
    x = directory
    if (length(x)!=4){
      stop('Input file check failed. Directory contains incorrect number of vcf files.')
    }
  }
  
  if(annotation == T) {
    mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
    freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
    varscan.tbi <- Sys.glob(paste0(directory,"*/varscan*.vcf.gz.tbi"))
    vardict.tbi <- Sys.glob(paste0(directory,"*/vardict*.vcf.gz.tbi"))
    tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi)
    
    if(length(grep("mutect", mutect2.tbi))!=1 & 
       length(grep("freebayes", freebayes.tbi))!=1 & 
       length(grep("varscan", varscan.tbi))!=1 & 
       length(grep("vardict", vardict.tbi))!=1) {
      print('tab-indexed (.tbi) files required for cdsannotation not found.')
      print('Generating .tbi files in directory...')
      library(Rsamtools)
      indexTabix(x[[1]], format = 'vcf')
      indexTabix(x[[2]], format = 'vcf')
      indexTabix(x[[3]], format = 'vcf')
      indexTabix(x[[4]], format = 'vcf')
      write("DONE",stdout())
    }
    
  }
  
  if (!is.null(parse.dir)) {
    if(dir.exists(parse.dir)==F){
      stop('parse.dir path does not exist. Assigning newcutoff requires path to parse.txt files')
    } else {
      print('Checking parse directory')
      snv.parse.dir <- Sys.glob(paste0(parse.dir,'/',"snv-parse*"))
      indel.parse.dir <- Sys.glob(paste0(parse.dir,'/',"indel-parse*"))
      
      if(length(snv.parse.dir)==1) {
           print(paste0(snv.parse.dir, ' found'))
        } else {
           print('snv-parse.txt not found or duplicated in parse.dir')
        }
      if(length(indel.parse.dir)==1) {
        print(paste0(indel.parse.dir, ' found'))      
      } else {
        print('indel-parse.txt not found or duplicated in parse.dir')
      }
      newcutoff = T
    }
  } else {
    newcutoff = F
  }
  
  if(!is.null(whitelist.file)){
    if(file.exists(whitelist.file)==F){
      stop("whitelist.bed file does not exist")
    } else if(file.exists(whitelist.file)==T){
      whitelist = T
      write("Using whitelist to subset VCFs.",stdout())
    } 
  } else {
    whitelist = F
  }
  
  if (!is.null(mode)){
    if (mode != "combined" & 
        mode != "snv" & 
        mode != "indel" & 
        mode != "featureselectionall"
    ) {
      stop('mode unrecognized')
    }
  }
  
  if (!is.null(build)) {
    if (build!='hg19' & build!='hg38') {
      stop('build unrecognized')
    }
  }
  
    #check for existing and required packages
    
  if(check.packages == T) {
    if (getRversion()<3.5) {
    
    if("VariantAnnotation" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("VariantAnnotation")
    }
    
    if("Rsamtools" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("Rsamtools")
      }
      
      #check for h2o version 3.10.3.3
      if("h2o" %in% rownames(installed.packages()) == FALSE){
        print("h2o version 3.10.3.3 not found. Installing required h2o package.")
        install.packages(paste0(find.package("smurf"), "/data/h2o_3.10.3.3.tar.gz"), type="source", repos=NULL)
        # install.packages("versions")
        # library(versions)
        # install.versions("h2o", versions = "3.10.3.3")
        print("h2o version 3.10.3.3 installed.")
        
      } else {
        if((packageVersion("h2o") == '3.10.3.3') == FALSE){
          print("Incorrect h2o version found. Installing h2o version 3.10.3.3.")
          if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
          if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
          install.packages(paste0(find.package("smurf"), "/data/h2o_3.10.3.3.tar.gz"), type="source", repos=NULL)
          # install.packages("versions")
          # library(versions)
          # install.versions("h2o", versions = "3.10.3.3")
          print("h2o version 3.10.3.3 installed.")
        }  
      }
      
    } else {
      
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    BiocManager::install()
    # BiocManager::install(c("VariantAnnotation"))
    }
    
    #check for h2o version 3.26.0.2
    if("h2o" %in% rownames(installed.packages()) == FALSE){
      print("h2o version 3.26.0.2 not found. Installing required h2o package.")
      # install.packages(paste0(find.package("smurf"), "/data/h2o_3.26.0.2.tar.gz"), type="source", repos=NULL)
      install.packages("versions")
      library(versions)
      install.versions("h2o", versions = "3.26.0.2")
      print("h2o version 3.26.0.2 installed.")
      
    } else {
      if((packageVersion("h2o") == '3.26.0.2') == FALSE){
        print("Incorrect h2o version found. Installing h2o version 3.26.0.2.")
        if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
        if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
        # install.packages(paste0(find.package("smurf"), "/data/h2o_3.26.0.2.tar.gz"), type="source", repos=NULL)
        install.packages("versions")
        library(versions)
        install.versions("h2o", versions = "3.26.0.2")
        print("h2o version 3.26.0.2 installed.")
      }  
      }
    }
  }
  
  if (! ("data.table" %in% rownames(installed.packages()))) { install.packages("data.table") }
  if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
  # if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
  if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
  if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
  if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
  if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
  if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
  if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
  if (! ("dplyr" %in% rownames(installed.packages()))) { install.packages("dplyr") }
    

    #load packages
  
    suppressWarnings(suppressMessages(library(VariantAnnotation)))

    suppressWarnings(suppressMessages(library(h2o)))
    suppressWarnings(h2o.init(nthreads = nthreads))
      
    
    #Retrieving files from the directory
    
    # write("Accessing files:", stderr())
    write("Accessing files:", stdout())
    # write(mutect2, stderr())
    # write(freebayes, stderr())
    # write(varscan, stderr())
    # write(vardict, stderr())
    write(mutect2, stdout())
    write(freebayes, stdout())
    write(varscan, stdout())
    write(vardict, stdout())
    
    start.time <- Sys.time()
    
    #### whitelist ####
    
    if (whitelist == T) {
      print('Retrieving whitelist...')
      
      parsevcf = parsevcf_allfeaturesall(x, roi=T, roi.dir=whitelist.file, t.label=t.label)
      
      parsevcf[[1]]$SMuRF_score = NA
      parsevcf[[2]]$SMuRF_score = NA
      
      if(nrow(parsevcf[[1]])!=0) {
        snvpredict<-newcutoff_snv(parsevcf, snv.cutoff=0)
      } else {parse_snv=NA}
      if(nrow(parsevcf[[2]])!=0) {
        indelpredict<-newcutoff_indel(parsevcf, indel.cutoff=0)
      } else {parse_indel=NA}
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (annotation == F) {
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("whitelist"=parsevcf, "time.taken"=time.taken))

      
      } else if (annotation == T) {
        
        if (length(snvpredict)>1) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        if (length(indelpredict)>1) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snv, "smurf_indel"=indel,
                    "smurf_snv_annotation"=snv.annotation, "smurf_indel_annotation"=indel.annotation,
                    "time.taken"=time.taken))
        
      }
    }
    
    #### newcutoff ####
    
    if (newcutoff == T) { #requires parse feature matrix for re-assigning cutoff and cdsannotation
      
      if(length(snv.parse.dir)==1) {
        parse_snv = read.table(snv.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
      } else {parse_snv=NA}
      if(length(indel.parse.dir)==1) {
        parse_indel = read.table(indel.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
      } else {parse_indel=NA}
      
      parsevcf = list(snv=parse_snv, indel=parse_indel)
      
      if(length(snv.parse.dir)==1) {
        snvpredict<-newcutoff_snv(parsevcf, snv.cutoff)
      } else {parse_snv=NA}
      if(length(indel.parse.dir)==1) {
        indelpredict<-newcutoff_indel(parsevcf, indel.cutoff)
      } else {parse_indel=NA}
      
      if (length(snvpredict)>1) {
        print("SNV annotation")
        snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
      } else {
        print("No snv predictions. Skipping snv annotation step.")
        snvannotation=NULL
      }
      
      if (length(indelpredict)>1) {
        print("Indel annotation")
        indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
      } else {
        print("No indel predictions. Skipping indel annotation step.")
        indelannotation=NULL
      }
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("smurf_snv"=snvpredict,
                                  "smurf_indel"=indelpredict,
                                  "smurf_snv_annotation"=snvannotation,
                                  "smurf_indel_annotation"=indelannotation,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
      
    }
    

    
    #### snv ####            

    if (mode == "snv") {
      
      if (newcutoff == T) {
        
        if(length(snv.parse.dir)==1) {
          parse_snv = read.table(snv.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
        } else {parse_snv=NA}

        parsevcf = list(snv=parse_snv, indel=NULL)
        
        if(length(snv.parse.dir)==1) {
          snvpredict<-newcutoff_snv(parsevcf, snv.cutoff)
        } else {parse_snv=NA}

      } else {
        parsevcf<-parsevcf_allfeaturesall(x,roi=F, roi.dir=NULL, t.label=t.label)
        snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
        # indelpredict<-indelRFpredict(parsevcf, indel.cutoff)
        
      }
      
      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "time.taken"=time.taken))
      
      } else if (annotation == T) {
        
        if (length(snvpredict)>1) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    # "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "smurf_snv_annotation"=snvannotation, "time.taken"=time.taken))

        }
      
      #### indel ####            
      
      } else if (mode == "indel") {
      
        if (newcutoff == T) { #requires parse feature matrix for re-assigning cutoff and cdsannotation
          
          if(length(indel.parse.dir)==1) {
            parse_indel = read.table(indel.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
          } else {parse_indel=NA}
          
          parsevcf = list(snv=NULL, indel=parse_indel)
          
          if(length(indel.parse.dir)==1) {
            indelpredict<-newcutoff_indel(parsevcf, indel.cutoff)
          } else {parse_indel=NA}
          
        } else {
          parsevcf<-parsevcf_allfeaturesall(x,roi=F, roi.dir=NULL, t.label=t.label)
          # snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)
        }

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list(#"smurf_snv"=snvpredict,
            "smurf_indel"=indelpredict,
            "time.taken"=time.taken),
            output.dir)
        }
        
        return(list("smurf_indel"=indelpredict, "time.taken"=time.taken))
        
      } else if (annotation == T) {
        
        if (length(indelpredict)>1) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list(#"smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    # "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        
        return(list("smurf_indel"=indelpredict, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
        
      }

      #### combined ####            

      } else if (mode == "combined") {
      
        if (newcutoff == T) { #requires parse feature matrix for re-assigning cutoff and cdsannotation
          
          if(length(snv.parse.dir)==1) {
            parse_snv = read.table(snv.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
          } else {parse_snv=NA}
          if(length(indel.parse.dir)==1) {
            parse_indel = read.table(indel.parse.dir, header = T, stringsAsFactors = F, na.strings='.')
          } else {parse_indel=NA}
          
          parsevcf = list(snv=parse_snv, indel=parse_indel)
          
          if(length(snv.parse.dir)==1) {
            snvpredict<-newcutoff_snv(parsevcf, snv.cutoff)
          } else {parse_snv=NA}
          if(length(indel.parse.dir)==1) {
            indelpredict<-newcutoff_indel(parsevcf, indel.cutoff)
          } else {parse_indel=NA}
          
        } else {
          parsevcf<-parsevcf_allfeaturesall(x,roi=F, roi.dir=NULL, t.label=t.label)
          snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)
        }
        
      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "time.taken"=time.taken))

      } else if (annotation == T) {
        
        if (length(snvpredict)>1) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        if (length(indelpredict)>1) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
        
      }

      #### featureselectionall ####            

    } else if (mode == "featureselectionall") { #debug mode, only parse feature matrix
      
      parsevcf<-parsevcf_allfeaturesall(x,roi=F, roi.dir=NULL, t.label=t.label)
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("parsevcf_featureselection"=parsevcf,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("parsevcf_featureselection"=parsevcf, "time.taken"=time.taken))
      
    }
    


}  
