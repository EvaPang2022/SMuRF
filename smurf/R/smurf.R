#' SMuRF v2.0
#'
#' Somatic mutation consensus calling based on four callers:
#' MuTect2, Freebayes, VarDict, VarScan
#' using a RandomForest model to consolidate a list of high accuracy calls.
#'
#' @note
#' Input files containing variant calls should be ".vcf.gz" format of each caller.
#' Supported for R >= 3.3.1, Java version 7 (up to 11) is supported. 
#' 
#' @param directory Choose directory where the Variant Caller Format(VCF) files are located. 
#' Alternatively, provide a list object containing the path to the 4 VCF files labelled: mutect, freebayes, vardict and varscan.
#'
#' @param mode Choose "snv", "indel" or "combined" (snv+indel). 
#' The appropriate parsing and prediction model will be performed
#' to obtain a list of somatic mutation calls. 
#' 
#' Debug mode: Choose "featureselectionall" to parse the VCF files only.
#' 
#' @param build Genome build='hg19' or "hg38". Please specify.
#' 
#' @param nthreads Default as "-1", where all available cores will be used for RandomForest prediction. 
#' Specify any integer from 1 to x, depending on your resources available.
#' For 32-bit Windows, only 1 core is allowed (nthreads=1).
#' 
#' @param annotation TRUE or FALSE (default). Provide gene annotations for each variant call.
#' 
#' @param snv.cutoff Default SNV model cutoff, unless a number between 0 to 1 is stated. 
#' 
#' @param indel.cutoff Default indel model cutoff, unless a number between 0 to 1 is stated.
#' 
#' @param output.dir Path to output directory (if saving files as .txt)
#' 
#' @param parse.dir Specify if changing SMuRF default cutoffs.
#' Path to the location of existing snv-parse.txt and indel-parse.txt files generated by SMuRF. 
#' 
#' @param change.build TRUE or FALSE. For conversion of your genomic coordinates.
#' Default option is disabled to retain your original 'build' specified above. 
#' 
#' @param t.label (optional) Provide the sample name for your tumour sample to ease 
#' the identification of the normal and tumour sample names in your vcf.
#' See examples below
#' 
#' @param re.tabIndex Default as FALSE. Set to TRUE if tab-indexed (.tbi) files for each vcf is missing.
#' 
#' @param check.packages Default as TRUE. For debug mode.
#' 
#' @examples
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="indel",build='hg19')
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="snv",build='hg19',
#'                   output.dir="/path/to/output")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined",build='hg19',
#'                   nthreads = 4,
#'                   snv.cutoff = 0.2, indel.cutoff = 'default')
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, build='hg19')
#' 
#' #Change hg38 to hg19 coordinates in gene annotation output
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', change.build=T)
#'                   
#' #Specify tumor sample name
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', t.label = '-T')
#'                                       
#' #Specify directories manually
#' dir.list = list(mutect='/path/to/mutect.vcf.gz',
#'                 freebayes='/path/to/freebayes.vcf.gz',
#'                 vardict='/path/to/vardict.vcf.gz',
#'                 varscan='/path/to/varscan.vcf.gz',
#'                 strelka='/path/to/strelka.vcf.gz')
#'                 
#' myresults = smurf(directory=dir.list, 
#'                   model="combined",build='hg19')
#'                                    
#' @export
#' 
smurf = function(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=F, output.dir=NULL, parse.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, t.label=NULL, re.tabIndex=F,
                 check.packages=T){
  
  #SMuRF version announcement
  print("SMuRFv2.0 (3rd July 2020)")
  

  if(is.null(directory)){
    # stop('directory path not specified')
    return(write("smurf(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=F, output.dir=NULL,  parse.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, t.label=NULL, re.tabIndex=F,
                 check.packages=T)", stdout()))
  }
  
  if(!is.null(directory) & class(directory)!='list'){
    if(dir.exists(directory)==F){
      stop('directory path does not exist')
    }
  }
  
  if(snv.cutoff != 'default' & (snv.cutoff < 0 | snv.cutoff > 1) ){
    stop('snv.cutoff out of range')
  }
  
  if(indel.cutoff != 'default' & (indel.cutoff < 0 | indel.cutoff > 1) ){
    stop('indel.cutoff out of range')
  }
  
  if (!is.null(output.dir)) {
    if(dir.exists(output.dir)==F){
      print(paste0('Creating output dir: ',output.dir))
      dir.create(output.dir)
      save.files = T
    } else {
      print(paste0('Saving output files to: ',output.dir))
      save.files = T
    }
  } else {
    save.files = F
  }
  
  
  if(is.null(build) & annotation == T){
    stop('Please specify genome build. build = "hg19" or "hg38".')
  }
  
  if (!is.null(build) & annotation == T) {
    if (build!='hg19' & build!='hg38') {
      stop('build unrecognized. Only hg19 or hg38 is allowed.')
    }
  }
  
  
  if (class(directory)!='list') {
    
    mutect2 <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz"))
    freebayes <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz"))
    varscan <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz"))
    vardict <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz"))
    strelka2 <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz"))
    
    #'germline' file filter
    # warning('VCF file names containing "germline" will be excluded.')
    if(length(mutect2)!=1){
      mutect2 = mutect2[-grep("germline", mutect2)]
    }
    if(length(freebayes)!=1){
      freebayes = freebayes[-grep("germline", freebayes)]
    }
    if(length(varscan)!=1){
        varscan = varscan[-grep("germline", varscan)]
    }
    if(length(vardict)!=1){
          vardict = vardict[-grep("germline", vardict)]
    }
    if(length(strelka2)!=1){
      strelka2 = strelka2[-grep("germline", strelka2)]
    }
    
    if(length(mutect2)!=1 |
       length(freebayes)!=1 |
       length(varscan)!=1 |
       length(vardict)!=1 |
       length(strelka2)!=1) {
      stop('Directory contains missing or duplicated vcf files. Alternatively, you may specify your path to caller files as a list object manually.')
    }
    
    #'germline' file filter
    # warning('VCF file names containing "germline" will be excluded.')
    
    # if(length(grep("strelka", strelka2))!=1) {
    #   warning('Strelka2 VCF not detected correctly. Use SMuRFv1.6 for 4 callers: Mutect2, Freebayes, Vardict, Varscan.')
    # }
    
    x<-list(mutect2,freebayes,varscan,vardict,strelka2)
    
  } else if (class(directory)=='list'){
    x = directory
    if (length(x)!=5){
      stop('Input file check failed. Directory contains incorrect number of vcf files.')
    }
  }
  
    
  if(re.tabIndex == F) {
    
      mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
      freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
      varscan.tbi <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz.tbi"))
      vardict.tbi <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz.tbi"))
      strelka2.tbi <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz.tbi"))
      
      #'germline' file filter
      # warning('VCF file names containing "germline" will be excluded.')
      if(length(mutect2.tbi)!=1){
        mutect2.tbi = mutect2.tbi[-grep("germline", mutect2.tbi)]
      }
      if(length(freebayes.tbi)!=1){
        freebayes.tbi = freebayes.tbi[-grep("germline", freebayes.tbi)]
      }
      if(length(varscan.tbi)!=1){
        varscan.tbi = varscan.tbi[-grep("germline", varscan.tbi)]
      }
      if(length(vardict.tbi)!=1){
        vardict.tbi = vardict.tbi[-grep("germline", vardict.tbi)]
      }
      if(length(strelka2.tbi)!=1){
        strelka2.tbi = strelka2.tbi[-grep("germline", strelka2.tbi)]
      }
      
    
    tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi,strelka2.tbi)
    
    if (length(mutect2.tbi)!=1 |
        length(freebayes.tbi)!=1 |
        length(varscan.tbi)!=1 |
        length(vardict.tbi)!=1 |
        length(strelka2.tbi)!=1|
        length(tbi)!=5){
      print('tab-indexed (.tbi) files required not found.')
      stop('Specify re.tabIndex=TRUE to re-index your vcf files.')
    }
    
    } else if (re.tabIndex == T){
      
      print('Generating .tbi files in directory...')
      
      library(Rsamtools)
      indexTabix(x[[1]], format = 'vcf')
      indexTabix(x[[2]], format = 'vcf')
      indexTabix(x[[3]], format = 'vcf')
      indexTabix(x[[4]], format = 'vcf')
      indexTabix(x[[5]], format = 'vcf')
      
      mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
      freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
      varscan.tbi <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz.tbi"))
      vardict.tbi <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz.tbi"))
      strelka2.tbi <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz.tbi"))
      
      #'germline' file filter
      # warning('VCF file names containing "germline" will be excluded.')
      if(length(mutect2.tbi)!=1){
        mutect2.tbi = mutect2.tbi[-grep("germline", mutect2.tbi)]
      }
      if(length(freebayes.tbi)!=1){
        freebayes.tbi = freebayes.tbi[-grep("germline", freebayes.tbi)]
      }
      if(length(varscan.tbi)!=1){
        varscan.tbi = varscan.tbi[-grep("germline", varscan.tbi)]
      }
      if(length(vardict.tbi)!=1){
        vardict.tbi = vardict.tbi[-grep("germline", vardict.tbi)]
      }
      if(length(strelka2.tbi)!=1){
        strelka2.tbi = strelka2.tbi[-grep("germline", strelka2.tbi)]
      }
      
      tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi,strelka2.tbi)
      
    }

      
  if (!is.null(mode)){
    if (mode != "combined" & 
        mode != "snv" & 
        mode != "indel" & 
        mode != "featureselectionall"
    ) {
      stop('mode unrecognized')
    }
  }
  
  
  #check for existing and required packages
    
  if(check.packages == T) {
    if (getRversion()<3.5) {
    
    if("VariantAnnotation" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("VariantAnnotation")
    }
    
    if("Rsamtools" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("Rsamtools")
    }
      
    if("rtracklayer" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("rtracklayer")
    }
      
    } else { #R>=3.5
      
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    BiocManager::install()
    BiocManager::install(c("VariantAnnotation"))
    }
    
    }
  }
  
  if (! ("data.table" %in% rownames(installed.packages()))) { install.packages("data.table") }
  if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
  # if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
  if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
  if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
  if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
  if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
  if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
  if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
  if (! ("dplyr" %in% rownames(installed.packages()))) { install.packages("dplyr") }
  #installs latest stable version of h2o
  if (! ("h2o" %in% rownames(installed.packages()))) { install.packages("h2o", type="source", repos=(c("http://h2o-release.s3.amazonaws.com/h2o/rel-yu/1/R"))) }
  

    #load packages
  
    suppressWarnings(suppressMessages(library(VariantAnnotation)))

    suppressWarnings(suppressMessages(library(h2o)))
    #nthreads = -1
    if(exists('nthreads')==F) {nthreads = -1}
    suppressWarnings(h2o.init(nthreads = nthreads))
      
    
    #Retrieving files from the directory
    
    write("Accessing files:", stdout())
    write(mutect2, stdout())
    write(freebayes, stdout())
    write(varscan, stdout())
    write(vardict, stdout())
    write(strelka2, stdout())
    
    start.time <- Sys.time()
    
    #### parse.dir ####

    if (!is.null(parse.dir)) {
      if(dir.exists(parse.dir)==F){
        stop('parse.dir path does not exist. Assigning newcutoff requires path to parse.txt files')
      } else {
        
        myresults = newcutoffs(parse.dir,
                               snv.cutoff, indel.cutoff)
        

        if (annotation == F) {
          
          if (save.files == T) {
            
            save.files(myresults,
                       output.dir)
          }
          
          return(myresults)
          
        } else if (annotation == T) {
          
          if (nrow(myresults$smurf_snv$predicted_snv)>1) {
            print("SNV annotation")
            snvannotation<-CDSannotation_snv(x,myresults$smurf_snv$predicted_snv,build=build,change.build=change.build)
          } else {
            print("No snv predictions. Skipping snv annotation step.")
            snvannotation=NULL
          }
          
          if (nrow(myresults$smurf_indel$predicted_indel)>1) {
            print("Indel annotation")
            indelannotation<-CDSannotation_indel(x,myresults$smurf_indel$predicted_indel,build=build,change.build=change.build)
          } else {
            print("No indel predictions. Skipping indel annotation step.")
            indelannotation=NULL
          }
          
          end.time <- Sys.time()
          time.taken <- end.time - start.time
          print(time.taken)
          
          if (save.files == T) {
            
            save.files(myresults,
                       output.dir)
            
            save.files(myresults=list("smurf_snv_annotation"=snvannotation,
                                      "smurf_indel_annotation"=indelannotation,
                                      "time.taken"=time.taken),
                       output.dir)
          }
          
          return(list(myresults, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
          
        }
        
      }
    }
    
    #### snv ####            

    if (mode == "snv") {
      
        parsevcf<-parsevcf_allfeaturesall(x,tbi,roi=F, roi.dir=NULL, t.label=t.label)
        snvpredict<-snvRFpredict(parsevcf, snv.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "time.taken"=time.taken))
      
      } else if (annotation == T) {
        
        if (length(snvpredict)>1) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,tbi,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    # "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "smurf_snv_annotation"=snvannotation, "time.taken"=time.taken))

        }
      
      #### indel ####            
      
      } else if (mode == "indel") {
      
          parsevcf<-parsevcf_allfeaturesall(x,tbi,roi=F, roi.dir=NULL, t.label=t.label)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list(#"smurf_snv"=snvpredict,
            "smurf_indel"=indelpredict,
            "time.taken"=time.taken),
            output.dir)
        }
        
        return(list("smurf_indel"=indelpredict, "time.taken"=time.taken))
        
      } else if (annotation == T) {
        
        if (length(indelpredict)>1) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,tbi,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list(#"smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    # "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        
        return(list("smurf_indel"=indelpredict, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
        
      }

      #### combined ####            

      } else if (mode == "combined") {
      
          parsevcf<-parsevcf_allfeaturesall(x,tbi,roi=F, roi.dir=NULL, t.label=t.label)
          snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "time.taken"=time.taken))

      } else if (annotation == T) {
        
        if (length(snvpredict)>1) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,tbi,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        if (length(indelpredict)>1) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,tbi,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }
        
        return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
        
      }

      #### featureselectionall ####            

    } else if (mode == "featureselectionall") { #debug mode, only parse feature matrix
      
      parsevcf<-parsevcf_allfeaturesall(x,roi=F, roi.dir=NULL, t.label=t.label)
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("parsevcf_featureselection"=parsevcf,
                                  "time.taken"=time.taken),
                   output.dir)
      }
      
      return(list("parsevcf_featureselection"=parsevcf, "time.taken"=time.taken))
      
    }
    
    # write("DONE",stdout())
    
}
